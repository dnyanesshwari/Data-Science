# -*- coding: utf-8 -*-
"""Numpy1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jxmHVjhHWC0CRhh0rh24BMpLRvRXut-P
"""

# analyse the time required for running list and numpy
import numpy as np
import time
size = 1_00_00
list1 = list(range(size))
list2 = list(range(size))
start = time.time()
result = [x + y for x, y in zip(list1,list2)]
end = time.time()
print("time required for run list : ",end-start)


arr1 = np.array(list1)
arr2 = np.array(list2)
start = time.time()
result = arr1 + arr2
end = time.time()
print("time required for run array : ",end-start)

#numpy arrays
import numpy as np
arr1 = np.array([[1,2,3],[4,5,6],[7,8,9]])
arr1
print("type :",type(arr1))
print("size :",arr1.size)
print("shape: ",arr1.shape)
print("dimensions :",arr1.ndim)
print("data type :",arr1.dtype)

#memory efficiency
import sys
list_data = list(range(1000))
numpy_data = np.array(list_data)
print("python list size :",sys.getsizeof(list_data)*len(list_data),"bytes")
print("numpy array size :",numpy_data.nbytes,"bytes")

#vectorization
'''vectorization is when numpy applies operations to multiple array
elements simultaneously using efficient CPU instructions bypassing
slow python code'''
list1 = [1,2,3,4]
arr1= np.array([list1])
list_square = [x ** 2 for x in list1]
numpy_square = arr1 ** 2
print("list square :",list_square)
print("numpy square :",numpy_square)

#changing the data types
arr = np.array([1,2,3,4], dtype=np.float32)

arr_int = arr.astype(np.int32)
print("data type of arr : ",arr.dtype)
print("data type of arr_int : ",arr_int.dtype)

#reshaping
arr = np.array([[1,2,3],[4,5,6],[7,8,9],[11,21,2]])
reshape = arr.reshape(2,6)
print("original array : \n",arr)
print("reshaped array : \n",reshape)

#indexing
arr = np.array([10,20,40,50])
print(arr[0],arr[-1])

#slicing
arr = np.array([10,20,40,60,20,45,50])
print(arr[:3])#print no from starting till 3
print(arr[1:])# from 1 position to last
print(arr[::2]) #every 2nd element

arr = np.array([10,20,34,45,40,50])
mask = arr>35
print(arr[mask])

arr = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(arr)
print(np.sum(arr,axis=0))
print(np.sum(arr,axis =1))
print("shape",arr.shape)
#access any element
print(arr[0,0])#1

"""**Brodcasting**"""

'''broadcasting when numpy automatically expand arrays of differnt shapes
to make them compatible for element-wise operations without actually replacing
data in memory '''
arr = np.array([2,3,4,5,6])
result = arr + 10
print(result)

arr1 = np.array([1, 2, 3])
arr2 = np.array([10, 20, 30])

result = arr1 + arr2  # Element-wise addition
print(result)  # Output: [11 22 33]

#broadcastingon 1d and 2d array
arr1 = np.array([[1,2,3],[4,5,6]])
arr2 = np.array([1,1,1])
result = arr1 + arr2
print(result)

#normalizing datausing broadcasting
data = np.array([[10,20,30],
                 [15,25,35],
                 [20,30,40],
                 [25,35,45],
                 [30,40,50]])
mean = data.mean(axis=0)
std = data.std(axis=0)

normalized_data = (data-mean)/std
print(normalized_data)

""" **Built in Mathematical Functions in NumPy**"""

arr = np.array([2,3,4,5,1,6])
print("mean :",np.mean(arr))
print("median :",np.median(arr))
print("standard deviation :",np.std(arr))
print("variance :",np.var(arr))
print("minimum value :", np.min(arr))
print("index of minimum :",np.argmin(arr))
print("maximum :",np.max(arr))
print("index of maximum :",np.argmax(arr))
print("sum",np.sum(arr))
print('product of all elements:',np.prod(arr))
print("percentile :",np.percentile(arr, 50))
print("unique element :",np.unique(arr))
print("n-th differences",np.diff(arr))
#Create an array with evenly spaced numbers over a specified interval.
print("linespace :",np.linspace(0,10,5)) # 5 numbers from 0 to 10
print("natural logarithm :",np.log(arr))
print("exponential:",np.exp(arr))

